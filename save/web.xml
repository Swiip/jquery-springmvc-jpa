<?xml version="1.0" encoding="utf-8"?>
<!-- web.xml is the official java web application descriptor. It's with this file that your server will know how to handle it -->
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5">

  <!-- This context parameter is the way we indicates to Spring where it has to find its configuration files -->
  <context-param>
    <param-name>contextConfigLocation</param-name>
    <!-- A word on the classpath"*": without the star, Spring class loader will only search in the project files and no in the jars. It has to be known 
      or it can be a long search before understanding why configuration files are not red. With the "classpath*:" all files with the right name in any jar will 
      match. It changes nothing in this example but it's an excuse to explain it -->
    <param-value>
      classpath*:META-INF/applicationContext*.xml
    </param-value>
  </context-param>

  <!-- This context parameter is the way configuring a Spring ApplicationContextInitializer to be launched at startup. Here we use it with the CloudFoundry 
    discovering tool in order to activate the right Spring profile whether the application works in CloudFoundry or not -->
  <context-param>
    <param-name>contextInitializerClasses</param-name>
    <param-value>org.cloudfoundry.services.CloudApplicationContextInitializer</param-value>
  </context-param>

  <!-- Open entity manager in view filter is the very useful filter which allow us to use lazy loaded join outside of transactional method (without, you 
    get no session with the data base and can't resolve the join). If this short explanation is not enough for you, I prefer to give you the link of the full 
    explanation: http://static.springsource.org/spring/docs/3.1.x/javadoc-api/index.html?org/springframework/orm/jpa/support/OpenEntityManagerInViewFilter.html -->
  <filter>
    <filter-name>openEntityManagerInViewFilter</filter-name>
    <filter-class>org.springframework.orm.jpa.support.OpenEntityManagerInViewFilter</filter-class>
    <init-param>
      <param-name>entityManagerFactoryBeanName</param-name>
      <param-value>entityManagerFactory</param-value>
    </init-param>
  </filter>

  <!-- Simplest is to refer to the official description: http://static.springsource.org/spring/docs/3.1.x/javadoc-api/index.html?org/springframework/web/filter/CharacterEncodingFilter.html -->
  <filter>
    <filter-name>encoding-filter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
      <param-name>encoding</param-name>
      <param-value>UTF-8</param-value>
    </init-param>
    <init-param>
      <param-name>forceEncoding</param-name>
      <param-value>true</param-value>
    </init-param>
  </filter>

  <!-- Spring Security declaration: it works as a standard filter -->
  <filter>
    <filter-name>springSecurityFilterChain</filter-name>
    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
  </filter>

  <!-- Open entity manager in view filter plugged on all dynamic requests -->
  <filter-mapping>
    <filter-name>openEntityManagerInViewFilter</filter-name>
    <url-pattern>/rest/*</url-pattern>
  </filter-mapping>

  <!-- Encoding filter on everything -->
  <filter-mapping>
    <filter-name>encoding-filter</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>

  <!-- Spring Security filter plugged on everything -->
  <filter-mapping>
    <filter-name>springSecurityFilterChain</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>

  <!-- Spring Framework startup is done with a listener -->
  <listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
  </listener>

  <servlet>
    <servlet-name>exporter</servlet-name>
    <servlet-class>org.springframework.data.rest.webmvc.RepositoryRestExporterServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
  </servlet>

  <!-- Spring MVC entry point is a "dispatcher" servlet -->
  <servlet>
    <servlet-name>spring</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
  </servlet>

  <servlet-mapping>
    <servlet-name>exporter</servlet-name>
    <url-pattern>/data-rest/*</url-pattern>
  </servlet-mapping>

  <!-- Spring MVC mapping is mapped only on the "rest" context, all other requests are static -->
  <servlet-mapping>
    <servlet-name>spring</servlet-name>
    <url-pattern>/rest/*</url-pattern>
  </servlet-mapping>

  <!-- Application welcome file and only page is the index.html -->
  <welcome-file-list>
    <welcome-file>index.html</welcome-file>
  </welcome-file-list>

</web-app>
